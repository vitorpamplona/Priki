options
{ 
	STATIC=false;
	IGNORE_CASE=true;
}

PARSER_BEGIN(HtmlTokenParser)

/*
 * Priki - Prevalent Wiki
 * Copyright (c) 2005 Priki 
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @author Vitor Fernando Pamplona - vitor@babaxp.org
 *
 */

package org.priki.format.compiler;

import java.io.StringReader;
import org.priki.utils.WikiwordUtils;
import org.priki.bo.*;
import java.util.*;
/**
 * Generated by JavaCC 
 * -OUTPUT_DIRECTORY=src/org/priki/format/compiler src/org/priki/format/compiler/priki-parser.jj
 * 
 * @author Vitor Fernando Pamplona
 */
public class HtmlTokenParser {

	private Wiki wiki;
	private boolean readonly;

	public HtmlTokenParser(Wiki wiki, String textToParse) {
		this(new StringReader(textToParse));
		this.wiki = wiki;	
		this.readonly= false;
	}
}

PARSER_END(HtmlTokenParser)

/*******************************************************************
 * The lexical grammar starts here d
 *******************************************************************/

SKIP:
{
		" "
	|	"\n"
	|	"\r"
	|	"\t"
}

TOKEN:  /* WikiWords */

/*  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> */

{

	   < A_TAG: <OPEN_A_TAG> 
    				(~["<"])* "<" 
		     			("/" <SPACES>
					    | ~["/", "a"] (~["<"])* "<"
					    )* 
			     "a" <SPACES>  ">" 
		>
	|   < CODE_TAG: <OPEN_CODE_TAG> 
    				(~["<"])* "<" 
		     			("/" <SPACES>
							 ("c" 
								 ("o"
								 | ~["o"] (~["<"])* "<"  
								 )           						     
						     | ~["c", " "] (~["<"])* "<"  
						     )
					    | "d" ~["e"]  (~["<"])* "<"
					    | ~["/", "d"] (~["<"])* "<" 
					    )* 
			       "de" <SPACES> ">" 
		>
	|   < PRE_TAG: <OPEN_PRE_TAG> 
    				(~["<"])* "<" 
		     			("/" <SPACES>
							 ("p" 
								 ("r"
								 | ~["r"] (~["<"])* "<"  
								 )           						     
						     | ~["p", " "] (~["<"])* "<"  
						     )
					    | "e" ~[" ",">"]  (~["<"])* "<"
					    | ~["/", "e"] (~["<"])*  "<"
					    )* 
			       "e" <SPACES> ">" 
		>
		
	|	< #OPEN_A_TAG:  "<a" <SPACES> <PROPERTIES> <SPACES> ">" >
	|	< #OPEN_PRE_TAG:  "<pre" <SPACES> <PROPERTIES> <SPACES> ">"  >
	|	< #OPEN_CODE_TAG: "<code" <SPACES> <PROPERTIES>  <SPACES> ">" > 

	|	< HTMLTAG:   "<" ("/")? <SPACES> <NAMES> <SPACES> <PROPERTIES> <SPACES>  ("/")? <SPACES> ">" >
	|	< SYMBOL:    (<NOTLETTERORDIGIT>) >
    |   < EMAIL:     (<DIGIT> | <LETTER>)+ "@" (<DIGIT> | <LETTER>)+ ("." (<DIGIT> | <LETTER>))+ ("." (<DIGIT> | <LETTER>) | (<DIGIT> | <LETTER>))+ >	
    |   < LINK:      ((( "https" | "http" | "ftp" | "file") "://") | "\\\\") (~["\n", "\r", "\t", " ", "<", ">", "("])+ (<DIGIT> | <LETTER>) >
    |	< WIKIWORD:  (<DIGIT> | <LETTER>) (["_", "\'", "+", "/", "\\"] | [".","-"] (<DIGIT> | <LETTER>) | <DIGIT> | <LETTER>)* >
    |	< NUMBER:    <DIGIT> ("." <DIGIT> | "-" <DIGIT> | "," <DIGIT> | "E" <DIGIT> | <DIGIT>)* ("%")? >
    |	< TIME:      <DIGIT> (":" <DIGIT> | <DIGIT>)*  >
	|	< DATE:      <DIGIT> ("/" <DIGIT> | <DIGIT>)*  >    
    |   < CODE: 	 "&" (~[";"])+ ";" >	

    |   < #PROPERTIES:  (<PROPERTY>|" ")* >
    |   < #PROPERTY:  <NAMES> "=" <STRING> >
    |   < #NAMES:  (<LETTER>|<DIGIT>)* >
    |   < #SPACE: [" "]>
    |   < #SPACES: ([" "])*>
	|   < #LETTER: [
	       "\u0024",
    	   "\u0041"-"\u005a",
	       "\u005f",
	       "\u0061"-"\u007a",
	       "\u00c0"-"\u00d6",
	       "\u00d8"-"\u00f6",
	       "\u00f8"-"\u00ff",
	       "\u0100"-"\u1fff",
	       "\u3040"-"\u318f",
	       "\u3300"-"\u337f",
	       "\u3400"-"\u3d2d",
	       "\u4e00"-"\u9fff",
	       "\uf900"-"\ufaff"]>
	|   < #NOTLETTERORDIGIT: ~[
	       "\u0024",
    	   "\u0041"-"\u005a",
	       "\u005f",
	       "\u0061"-"\u007a",
	       "\u00c0"-"\u00d6",
	       "\u00d8"-"\u00f6",
	       "\u00f8"-"\u00ff",
	       "\u0100"-"\u1fff",
	       "\u3040"-"\u318f",
	       "\u3300"-"\u337f",
	       "\u3400"-"\u3d2d",
	       "\u4e00"-"\u9fff",
	       "\uf900"-"\ufaff", 
	       "0"-"9"]>	       
	|	< #DIGIT: ["0"-"9"] >
	|   < #SOMECHAR: ["\u0024"-"\uffff"]>	
	|   < #STRING: ( "\"" (~["\""])* "\"" | "\'" (~["\'"])* "\'" ) >
}


/*******************************************************************
 * The SQL syntatic grammar starts here !
 *******************************************************************/

void parseString(Text text) :
{
	Element e;
}
{
 	(     e = notChangeTag() {text.add(e);}
	    | e = htmlTag() {text.add(e);}
	    | e = emailTag(){text.add(e);}	    
		| e = code()    {text.add(e);}			    
		| e = link()    {text.add(e);}		
		| e = symbol()  {text.add(e);}
        | e = wikiword() {text.add(e);}
	)* 
}

void parseStringInReadOnlyMode(Text text) :
{
	Element e;
}
{
	{readonly = true;}
	(     e = notChangeTag() {text.add(e);}
	    | e = htmlTag() {text.add(e);}
	    | e = emailTag(){text.add(e);}
		| e = code()    {text.add(e);}			    
		| e = link()    {text.add(e);}		
		| e = symbol()  {text.add(e);}
        | e = wikiword() {text.add(e);}
	)* 
}

void getWikiwords(List<Wikiword> list) :
{
	Wikiword word;
}
{
	( word = wikiword() { if (word != null) list.add(word); } )* 
}

void splitWikiword(List<Wikiword> list) :
{
	Wikiword word;
}
{
	{ readonly = true; }
	( word = singleWikiword() { if (word != null) list.add(word); } )* 
}

Wikiword singleWikiword() :
{
	Wikiword word;
}
{
	<WIKIWORD>
	{ 
		return readonlyWikiwordStrategy(token.image);
	}
}

Wikiword wikiword() :
{
	Wikiword word;
}
{
	<WIKIWORD>
	{ 
		word = recursiveWikiwordSearcher(token.image, 1);

		if (word == null) {
			// Consider only the first word
			word = readonlyWikiwordStrategy(token.image); 
		}

		return word;
	}
}

Wikiword recursiveWikiwordSearcher(String name, int index) :
{ 
	String temp; 
	Wikiword word;
}
{
	{ 
		Collection<Wikiword> coll = wiki.wordsStartingWith(name);	
		
		if (coll.size() == 0) {
			// Can't exists this wikiword.
			return null;
		}

		if (coll.size() == 1) {
			// Check if the wikiword is equals the key.
			word = coll.iterator().next();
			if (WikiwordUtils.equalsKeyword(name, word)) {
				// Remove from tokens list
				return word;
			} 
		}
	
		// There are many possibles to this key.
		// Try with more tokens
			
		temp = getToken(index).image;
		if (temp != null) {
			
			word = recursiveWikiwordSearcher(name + " " + temp, index+1);
			
			// Remove from tokens list
			if (word != null) {
				getNextToken();
				return word;
			} else {
				for (Wikiword compositeWord : coll) {
					if (WikiwordUtils.equalsKeyword(name, compositeWord)) {
						return compositeWord;
					}
				}
			}	
		}
		
		return null;
	}
}

Wikiword readonlyWikiwordStrategy(String key) :
{}
{
	{ 
		Wikiword ret = wiki.getWikiwordIgnoreCase(key);
		if (ret != null) {
			return ret;
		} else {
			if (readonly)
				return new Wikiword(key); 
			else
				return wiki.newWikiword(key);
		}
	}
}

Element readonlyElementStrategy(String key) :
{}
{
	{ 
		if (wiki.hasElement(key)) {
			return wiki.getElement(key);
		} else {
			if (readonly)
				return new Element(key); 
			else
				return wiki.newElement(key);
		}
	}
}
	

Element code() :
{}
{
	<CODE>
	{ 	
		return readonlyElementStrategy(token.image); }
}

Element htmlTag() :
{}
{
	<HTMLTAG>
	{ return readonlyElementStrategy(token.image); }
}

Element emailTag() :
{}
{
	<EMAIL>
	{ return readonlyElementStrategy(token.image); }
}

Element notChangeTag() :
{ String ret; }
{
	( <A_TAG> | <PRE_TAG> | <CODE_TAG> | <NUMBER> | <DATE> | <TIME>)
	{ return readonlyElementStrategy(token.image); }
}

Element symbol() :
{}
{
	<SYMBOL>
	{ return readonlyElementStrategy(token.image); }
}

Element link() :
{}
{
	<LINK>
	{ return readonlyElementStrategy(token.image.trim()); }
}


